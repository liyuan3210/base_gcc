			一.Linux内存管理
描述：
	内存是linux内核所管理的最重要的资源之一，内存管理子系统是操作系统中最重要的部分之一,对于立志从事内核开发的工程师来说，熟悉Linux的内存管理系统非常重要的。

地址之间的关系：
	·逻辑地址
	程序代码经过编译后，出现在汇编程序中的地址。
	↓
	(段式内存管理单元)
	↓
	·线性地址(虚拟地址)
	在32位cpu架构下，可以表示4G的地址空间，用16进制表示就是0x00000000到oxffffffff
	↓
	(页式管理单元)
	↓
	·物理地址
	出现在cpu地址总线上的寻址物理内存的地址型号，是地址变换的最终结果

段式管理:
	因:16位cpu内部拥有20位的地址线(寻址范围2的20次方)，也就是1M内存空间。但是16位cpu只有16位的寄存器，因此只能访问65536个存储单元即64k.所以如下：
	所:为了能够访问1M的内存空间，cpu就采用了段式管理模式,并在cpu内部加入了 段寄存器。16位cpu把1M内存分为若干个逻辑段，每个逻辑段要求如下：
	↓
	1.逻辑段的起始地址(起始地址)必须是16的倍数,即最后4个二进制必须全为0.
	2.逻辑段的最大容量为64(why?)  
	↓
	鉴于上面的这种特性，所以16位地址左移4位，只有前面十六位是变化的，后面四个0是固定不变的，
	乘以16来得到实际的段地址。在确定了某个存所属的段后，只是知道了该存储单元所属的范围（段地址->段地址+65536）,如果想确定该内存单元的具体位置，还必须知道单元在段内的偏移。
	
	1)公式：
	有了段地址 和 偏移量，就可以唯一的确定内存单元在存储器中的具体位置。
	逻辑地址=段基地址+段内偏移量
	物理地址=段寄存器的值*16+逻辑地址

	2)四个不同含义的段：见:du1.jpg，du2.jpg,du3.jpg

	3)32位的cpu:
	32位仍然采用分段的管理模式，采用了两种不同的工作方式:实模式(与16位的一致) 和 保护模式

	4)保护模式的不同：
	段基地址长达32位，每个段的最大容量可达4G，段寄存器的值是段地址的“选择器”(selector),
	用该选择器从内存中得到一个32位的段地址，存储单元的物理地址就是该段地址加上段内偏移量，
	这与32位cpu的物理地址计算公式完全不同。
	32位段:du32.jpg

页式管理:
	从管理和效率的角度出发，线性地址被分为固定长度的组，称为页(页)，例如32位的机器，线性地址最大可为4G，如果用4k为一个页来划分，这样整个线性地址就可以划分为2的20次方个页。段可以是不固定的，页要分成固定的组。

	1)物理页(物理页，或是页框，页桢)：
	分页单元也把物理内存也划分为固定长度的管理单位，它的长度与线性地址是相同的。(实际的物理地址)通过中间一个映射关系把页(线性地址转换成的页)转换成实际的物理页,

	2)见:pagemg2.jpg(两级模型)描述如下：
	1>分页单元中，页目录的地址存放在cpu的cr3寄存器中，是进行地址转换的开始点。
	2>每一个进程都有其独立的虚拟地址空间，运行一个进程，首先需要将它的页目录地址存放到cr3寄存器中，
	将其他进程保存下来。
	3>每一个32位的线性地址被划分为三部分，页目录索引(10位),页表索引(10位)，偏移（12位）

	3)由pagemg2.jpg得出公式：
	页大小：2的12次方(4k)
	4G=2的十次方 * 2的十次方

	4)前面说了很多X86，现在回到linux:
	1>linux段式使用：linux内核设计并没有全部采用intel所提供的段机制，仅仅是有限度使用了分段机制或者说没有使用。这不仅简化了linux内核的设计，而且为把linux移植到其它平台创造了条件，因为很多RISC处理器并不支持段机制.见:xslinux.jpg
	2>linux页式使用:linux完全使用了页式管理
	前面介绍了i386的二级页管理架构，不过有些cpu使用三级，甚至是四级，linux2.6.29内核为每种cpu提供统一的界面，采用了四级页管理架构，来兼容二级，三级，四级管理架构的cpu。见:fourgl.jpg。

	5)这四级分别为：
	1>页全局目录(page global directory):即pgd,是多级页表的抽象最高层.
	2>页上级目录(page upper dirctory):即pud.
	3>页中间目录(page middle dirctory):即pmd，是页表的中间层.
	4>页表(page table entry):即pte。
-----------------------------------------------------------------------------
			二.进程地址空间
描述：
	linux系统采用虚拟内存管理技术，使得每个进程都有独立的进程地址空间，该进程大小是3G，用户接触的地址都是虚拟的地址，无法看到实际的物理地址。利用这种技术不但能起到保护操作系统，更重要的是用户程序可使用比实际物理内存更大的地址空间。

linux将4G虚拟空间划分为：
	·用户空间：0到0xbfffffff
	·内核空间：内核空间3G到4G。
	用户进程通常情况只能够访问用户虚拟地址，不能够访问内核空间。例外只能够通过系统调用访问内核空间。
	用户空间对应进程，所以没当进程切换，用户空间就会随着变化.

实验确认：
    把一个程序连续运行十次，使用pu -aux查看进程，然后使用cat /proc/<pid>/maps,会发现它使用的是同样的地址。fork,execve,malloc等进程相关操作都需要分配内存给进程，这时分配的内存不是物理地址，仅仅是虚拟地址，实际的物理内存只有当进程真的去访问新获取的虚拟地址时，才会由"请页机制"产生"缺页"异常，从而进入分配实际页框的程序。(该异常是虚拟内存机制赖以存在的基本保证--它会告诉内核为进程分配物理页，并建立对应的页表，这之后虚拟地址才实实在在的映射到了物理地址上)

内核内存分配:
	在应用程序中使用malloc函数进行动态分配内存，而在linux内核中通常使用kmalloc来动态分配内存。
	include <linux/slab.h>
	1)void *kmalloc(size_t size,int flags)
	参数：
	size:要分配内存的大小
	flags:分配标志，它控制kmalloc的行为。
	flags最常用的标志是GFP_KERNEL(16M-896M):
	它的意思是该内存分配是由运行在内核的进程调用的。也就是说，调用它的函数属于某个进程的，当空闲太少时，kmalloc函数会使当前进程进入睡眠，等待空闲的出现。
	flags其它：
	·GFP_ATOMIC:用来在进程上下文之外的代码(包括中断处理)中分配内存，从不睡眠。
	·_GFP_DMA:这个标志要求分配能够DMA的内存区(16M以下的页帧)
	·_GFP_HIGHMEM:这个标志表示分配的内存位于高端内存（896以上）
	2)按页分配：
	如果要分配大块的内存，那使用面向页的分配技术会更好
	·get_zeroed_page(unsigned int flags):返回指向新页面的指针，并将页面清零.
	·_get_free_page(unsigned int flags):和get_zeroed_page类似，但不清零
	·_get_free_pages(unsigned int flags,unsigned int order)
	分配若干个连续的页面，返回指向该内存区域的指针，但也不请零这段内存区域
	3)释放：
	当程序使用完这些页与内存，可以使用下列函数之一来释放它们:
	·void free_page(unsigned long addr)
	·void free_pages(unsigned long addr,unsigned long order)
	如果释放的和先前分配数目不等的页面，会导致系统错误

	内存使用分配:见 memuse.jpg
-----------------------------------------------------------------------------
			三.内核地址空间
描述：
	内核空间是由内核负责映射的，它不会跟着进程改变，是固定的，896M以上的部分称为高端内存。

内核空间分布：见 kernelSpaceMg.jpg

阶段详细介绍:
	·直接映射区
	从3G开始，最大896M的线性地址区间，我们称作 直接内核映射区，这是因为该区域的线性地址和物理地址之间存在线性转换关系：线性地址=3G+物理地址
	例如：物理地址区间0x10000000-0x20000000映射到线性空间就是：3G+0x10000000-3G+0x20000000
	·动态映射区
	该区域的地址由内核函数vmalloc来进行分配，其特点是线性空间连续，但对应的物理空间不一定连续。vmalloc分配的线性地址所对应的物理页可能处于低端内存，页可能处于高端内存。
	·永久内存映射区
	对于896以上的高端内存，可使用该区域来访问，方法如下：
	1)alloc_page(_GFP_HIGHMEM)分配高端内存页
	2)然后使用kmap函数将分配到的高端内存映射到该区域
	实际上是访问高端内存的一个窗口。(4M可以访问896以上的所有地址)
	·固定映射区
	PKmap区上面，有4M的线性空间，被称为固定映射区，它和4G顶端只有4K的隔离带。固定映射区中每个地址项都服务于特定的用途，如ACPI_BASE等.
-----------------------------------------------------------------------------
			四.Linux内核链表
描述：
	链表是常用的数据结构，相比数组链表具有更好的动态性。建立链表时无需预先知道数据总量，可以随机分配空间，
	可以高效地在链表中的任意位置实时插入或删除数据。通常链表至少包括两个域：数据域 与 指针域
链表分类：
	·单链表：见 danlb.jpg
	·双链表：见 shuanglb.jpg
	·循环链表
linux内核链表:
	内核中大量使用了链表来组织数据，这些链表大多采用在include/linux/list.h中实现的一套经典的链表数据结构
	链表结构定义:
	struct list_head
	{
	struct list_head *next,*prev;
	}
	list_head结构包含两个指向list_head结构的指针prev和next,由此可见，内核的链表具备双链表功能，实际上，通常它都组织成双向循环链表.
链表方法使用:
	·INIT_LIST_HEAD(list_head *head)
	初始化链表，把链表prev,next指向自身。
	·list_add(struct list_head *new,struct list_head *head)
	在链表头插入一个节点。
	·list_add_tail(struct list_head *new,struct list_head *head)
	在链表尾插入一个节点。
	·list_del(struct list_head *entry)
	删除节点
	·list_entry(ptr,type,member)
	提取数据结构
	·list_for_each(struct list_head *pos,struct list_head *head)
	pos:表示获取要赋的值在pos里面
	head:表示要遍历的头
	便利数据
-----------------------------------------------------------------------------
			五.Linux内核定时器
描述：
	时钟中断由系统的定时硬件以周期性的时间间隔产生，这个间隔(即频率)由内核根据HZ来确定，HZ是一个与体系结构无关的常数，可配置(50-1200),在x86平台，默认是1000。

全局变量jiffies:

	每当时钟中断发生时，jiffies(unsigned long)就加1，因此jiffies记录了自linux启动后时钟中断发生的次数。驱动程序常利用jiffies来计算不同事件的时间间隔.
延迟执行:
	如果对延迟的精度要求不高，最简单的实现方法如下：
	unsigned long j=jiffies+jit_delay*HZ;
	while(jiffies<j)
	{
	/*do nothing*/
	}

定时器用于控制某个函数(定时器处理函数)在未来的某个时间执行。内核定时器注册的处理函数只执行一次--不是循环执行的。

内核定时器结构：
	内核定时器被组织成双向链表，结构如下：
	struct timer_list{
	struct list_head entry;/*内核使用*/
	unsigned long expires;/*超市的jiffies值*/
	void (*function)(unsigned long);/*超市处理函数*/
	unsigned long data;/*超市处理函数参数*/
	struct tvec_base *base;/*内核使用*/
	};

内核定时器函数:
	·void init_timer(struct timer_list *timer)
	初始化定时器队列结构
	·void add_timer(struct timer_list *timer)
	启动定时器
	·int del_timer(struct timer_list *timer)
	在定时器超时前将它删除。定时器超时后系统会自动地将它删除
-----------------------------------------------------------------------------
实验：
	实验1要求：
	1.编写内核模块，在模块中使用kmalloc分配内存并访问
	2.编写内核模块，在模块中使用页方式分配内存并访问
	实验代码：5-4-1
	编译开发板上运行程序(两种方法):
	·在编译时需要加-static
	·使用arm-linux-readlf -d app-mem查看动态连接库并把要使用的动态连接库加到开发板/lib里面

	实验2要求：
	1.编写内核模块,在模块中创建一链表
	2.遍历该链表
	3.删除表中的结点
	实验代码：5-4-2

	实验3要求：
	编写内核模块，在模块中启动一定时器，5秒后超时，超时后任意打印一条信息
	实验代码：5-4-3
